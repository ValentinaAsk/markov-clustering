# Алгоритм кластеризации Маркова

* [Формальная постановка задачи](#1)
* [Подходы к решению задачи](#2)
* [Алгоритм кластеризации Маркова](#3)

<a name="1"></a>
## Формальная постановка задачи
Необходимо реализовать один из алгоритмов кластеризации графов – например, label
propogation или infomap.

По условию задачи, входными и выходными данными программы будет граф. Для удобства условимся, что граф будет представлен в виде матрицы смежности. Также, для задачи кластеризации необходимо задать "критерий похожести", по которому распределять далее вершины по кластерам. Это подразумевает наличие метрического пространства и заданной функции метрики для каждой пары вершин графа. 

Под кластеризацией подразумевается разбиение входного множества на группы схожих объектов. Это означает, что алгоритм кластеризации - это функция ![func](http://latex.codecogs.com/png.latex?%5Calpha%20%3A%20V%20%5Crightarrow%20V%27), которая любой вершине из ![invertexes](http://latex.codecogs.com/png.latex?V) ставит в соответствие кластер из ![vertexes](http://latex.codecogs.com/png.latex?V%27).

Формально, задачу можно описать так: 
1. Вход: граф ![input graph](http://latex.codecogs.com/gif.latex?G%28V%2CE%29), функция расстояния между вершинами графа ![metrica](http://latex.codecogs.com/png.latex?%5Crho%20%28v%2C%20v%27%29). Опционально: задано количество кластеров ![len](http://latex.codecogs.com/png.latex?%5Cleft%20%7CV%27%20%5Cright%20%7C)
2. Выход: граф ![output graph](http://latex.codecogs.com/png.latex?G%27%28V%27%2C%20E%27%29), в котором ![vertexes](http://latex.codecogs.com/png.latex?V%27) - множество кластеров, таких что каждый кластер состоит из объектов из  ![invertexes](http://latex.codecogs.com/png.latex?V), близких по метрике ![ro](http://latex.codecogs.com/png.latex?%5Crho)


<a name="2"></a>
## Подходы к решению задачи
В настоящее время существует множество алгоритмов кластеризации графов, все они создавались для решения конкретно поставленных задач, так что стоит четко понимать какая задача решается. Так например, результатом работы некоторых алгоритмов является непересекающиеся разбиение графа, при этом другие алгоритмы допускают пересечение кластеров или могут не относить некоторые вершины ни к одному из кластеров. Рассмотрим алгоритмы, работающие с взвешенными графами и не требующие заранее задания количества кластеров.

### Louvain Method
Достаточно популярный метод, на основе которого был также реализован Infomap. 

Алгоритм базируется на определение modularity (будем называть модульностью в дальнейшем) и её оптимизации по мере продвижения алгоритма. Под модульностью понимается величина от -1 до 1, характеризующая плотность рёбер внутри кластеров по сравнению с количеством ребер между кластерами. Оптимизация этого значения теоретически приводит к наилучшей возможной группировке вершин графа.

Метод состоит из двух стадий. На первой происходит поиск пар кластеров для объединения, дающих максимально возможный прирост модульности. На второй стадии вершины объединяются в кластеры и строится новый граф большего масштаба, после чего эти стадии повторяются до тех пор, пока не будет достигнут максимальный уровень модульности. 

Значение модульности представляет собой ![modularity](https://wikimedia.org/api/rest_v1/media/math/render/svg/bd7498b437de5c6bc34f7cc44fba306122350202), где
* ![Aij](http://latex.codecogs.com/png.latex?A_%7Bij%7D) - вес ребра между вершинами ![i](http://latex.codecogs.com/png.latex?i) и ![j](http://latex.codecogs.com/png.latex?j)
* ![ki](http://latex.codecogs.com/png.latex?k_%7Bi%7D) и ![kj](http://latex.codecogs.com/png.latex?k_%7Bj%7D) сумма весов рёбер, входящих в вершины  ![i](http://latex.codecogs.com/png.latex?i) и ![j](http://latex.codecogs.com/png.latex?j)
* ![m](http://latex.codecogs.com/png.latex?m) сумма весов всех рёбер графа
* ![сi](http://latex.codecogs.com/png.latex?c_%7Bi%7D) и ![сj](http://latex.codecogs.com/png.latex?c_%7Bj%7D) - соответствующие кластеры
* ![delta](http://latex.codecogs.com/png.latex?%5Cdelta) - функция-индикатор равенства элементов (дельта Кронекера)

#### Алгоритм

Первая стадия. Каждой вершине ![i](http://latex.codecogs.com/png.latex?i) присваивается свой кластер. Затем для ![i](http://latex.codecogs.com/png.latex?i) высчитывается изменение модульности для каждого соседнего кластера путем удаления вершины из своего кластера и перемещения в соседний. То есть для каждого соседнего кластера будет посчитана новая модульность, затем ![i](http://latex.codecogs.com/png.latex?i) помещается в кластер с наибольшим изменением модульности. Это повторяется для всех вершин пока есть изменение модульности в лучшую сторону.

Вторая стадия. Алгоритм создает новый граф, объединяя кластеры в одну вершину. Все внутренние ребра кластера заменяются петлями, а все внешние идут в соответствующий кластер-вершину.

Затем итеративно повторяется первая фаза и так до наступления максимального уровня модульности (когда уже не будет происходить никаких изменений).

#### Сложность

В худшем случае сложность алгоритма порядка ![complex](http://latex.codecogs.com/png.latex?O%28mn%5Clog%20n%29), где ![m](http://latex.codecogs.com/png.latex?m) - количество рёбер в графе.

Однако алгоритмы, использующие модульность не замечают мелкие (относительно всего графа) кластеры и объединяют их в один. Эта проблема получила название resolution limit. 

### Label propogation
В этом алгоритме итеративно пересчитываются метки кластеров для каждой вершины. На каждой итерации вершины перемешиваются случайным образом, и по очереди для каждой вершины обновляется её метка в зависимости от меток её соседей. Процесс прекращается, когда у каждой вершины та же метка, что и у её соседей. 

#### Алгоритм

Инициализация. Каждой вершине из ![vertexes](http://latex.codecogs.com/png.latex?V%27) сопоставим метку из ![c](http://latex.codecogs.com/png.latex?C), обозначающую кластер, к которому вершина принадлежит. Для вершины ![v](http://latex.codecogs.com/png.latex?v) метка вершины на 0-ой итерации ![cv](http://latex.codecogs.com/png.latex?C_%7Bv%7D%280%29%20%3D%20v). Затем увеличим итерацию ![t](http://latex.codecogs.com/png.latex?t%20%3D%201).

Шаг алгоритма. Перемешиваем вершины графа в произвольном порядке и устанавливаем в ![V](http://latex.codecogs.com/png.latex?V). Для каждой ![vinV](http://latex.codecogs.com/png.latex?v%5Cin%20V), выбранной в этом конкретном порядке, ![equation](http://latex.codecogs.com/png.latex?%5Clarge%20C_%7Bx%7D%28t%29%20%3D%20f%28C_%7Bx_%7Bi1%7D%7D%28t%29%2C%20...%2C%20C_%7Bx_%7Bim%7D%7D%28t%29%2C%20C_%7Bx_%7Bim&plus;1%7D%7D%28t%29%2C%20...%2C%20C_%7Bx_%7Bik%7D%7D%28t%29%29). 

![f](http://latex.codecogs.com/png.latex?f) здесь возвращает метку, наиболее часто встречающуюся среди соседей.

Если у каждой вершины та же метка, что и у максимального количество её соседей, алгоритм останавливается. Иначе увеличиваем итерацию ![t+1](http://latex.codecogs.com/png.latex?t%20%3D%20t%20&plus;1) и повторяем шаг алгоритма.

#### Сложность

Инициализация каждой вершины с помощью уникальных меток требует ![linear](http://latex.codecogs.com/png.latex?O%28n%29). Сложность шага алгоритма зависит от числа рёбер ![complexity](http://latex.codecogs.com/png.latex?O%28m%29).
Для каждой ![v](http://latex.codecogs.com/png.latex?v) сначала группируются соседи по их меткам, затем выбирается кластер максимального размера и его метка присваивается ![v](http://latex.codecogs.com/png.latex?v), требуя ![compl1](http://latex.codecogs.com/png.latex?O%28d_%7Bx%7D%29). Этот процесс повторяется на всех узлах и, следовательно,
общее время ![complexity](http://latex.codecogs.com/png.latex?O%28m%29) для каждой итерации.

Касательно количества итераций. С каждой новой итерацией, увеличивается и количество правильно кластеризованных вершин. При этом, согласно исследованиям разработчика, уже 95% вершин правильно кластеризованы к 5-ой итерации, не зависимо от числа вершин графа. Поэтому в худшем случае сложность алгоритма порядка ![complexity](http://latex.codecogs.com/png.latex?O%28m%29).

У алгоритма имеется ряд преимуществ: быстрое время работы, нет необходимости заранее определять параметры. Однако главный недостаток, что он не создает уникального решения, а представляет собой совокупность решений.

<a name="3"></a>
## Алгоритм кластеризации Маркова
Алгоритм кластеризации Маркова основан на утверждении, что внутри кластера будет много рёбер и мало между кластерами.  
Т.е. в рамках идеи случайного блуждания: если вы окажетесь в какой-то вершине графа и будете случайным образом переходить в соседние ей, то переходы из одного кластера в другой будут происходить достаточно редко.
На сегодняшний день данный алгоритм имеет широкий спектр применений, например, для данных в молекулярной биологии.

Сам алгоритм вычисляет вероятности случайных блужданий в графе с использованием двух алгебраических операций на матрицах, преобразующих один набор вероятностей в другой: распространение (expansion) и накачивание (inflation). 

**Распространение** соответствует стандартному умножению стохастических матриц (матрица называется стохастической, если каждый ее столбец в сумме дает 1). 

В основе **накачивания** лежит умножение Адамара, которое выполняется следующим образом:

![multi](http://latex.codecogs.com/png.latex?A%5Ccdot%20B%20%3D%20%5Cbegin%7Bpmatrix%7D%20A_%7B11%7D%20%26%20...%20%26%20A_%7B1m%7D%20%5C%5C%20A_%7Bn1%7D%20%26%20...%20%26%20A_%7Bnm%7D%20%5Cend%7Bpmatrix%7D%20%5Ccdot%20%5Cbegin%7Bpmatrix%7D%20B_%7B11%7D%20%26%20...%20%26%20B_%7B1m%7D%20%5C%5C%20B_%7Bn1%7D%20%26%20...%20%26%20B_%7Bnm%7D%20%5Cend%7Bpmatrix%7D%20%3D%20%5Cbegin%7Bpmatrix%7D%20A_%7B11%7DB_%7B11%7D%20%26%20...%20%26%20A_%7B1m%7D%20B_%7B1m%7D%20%5C%5C%20A_%7Bn1%7DB_%7Bn1%7D%20%26%20...%20%26%20A_%7Bnm%7D%20B_%7Bnm%7D%20%5Cend%7Bpmatrix%7D)

Формула для операции накачивания:  ![inflation](http://latex.codecogs.com/png.latex?%5CGamma%20%28M_%7Bij%7D%29%20%3D%20M_%7Bi%2Cj%7D%5E%7Br%7D%20/%20%5Csum%20M_%7Bi%2Cj%7D%5E%7Br%7D), где
* ![mij](http://latex.codecogs.com/png.latex?M_%7Bij%7D%5E%7Br%7D) - матрица, полученная возведением в степень исходной матрицы по правилу Адамара
* ![summij](http://latex.codecogs.com/png.latex?%5Csum%20M_%7Bi%2Cj%7D%5E%7Br%7D) - сумма всех элементов j-го столбца матрицы M, каждый из которых возведен в степень r.

#### Алгоритм

Инициализация. Составить матрицу ![M1](http://latex.codecogs.com/png.latex?M_%7B1%7D), которая случайным образом обходит исходный граф ![input graph](http://latex.codecogs.com/gif.latex?G%28V%2CE%29).

Шаг алгоритма.
Распространение: ![expansion](http://latex.codecogs.com/png.latex?M_%7B2%7D%20%3D%20M_%7B1%7D%20%5Ccdot%20M_%7B1%7D), накачивание ![inflation](http://latex.codecogs.com/png.latex?M_%7B1%7D%20%3D%20%5CGamma%20%28%20M_%7B2%7D%29).
Затем пересчитываем разницу ![change2](http://latex.codecogs.com/png.latex?Change%20%3D%20M_%7B1%7D%20-%20M_%7B2%7D)

И повторяем шаг алгоритма пока разница не будет равна 0.

#### Сложность

Данный алгоритм является быстрым и хорошо масштабируемым для больших данных. Вычислительная сложность, согласно данным официального автора, составляет ![cmplx3](http://latex.codecogs.com/png.latex?O%28n*k*k%29), где n — количество узлов в графе, а k - максимальная степень вершины графа.

На вход программы не должно подаваться количество кластеров, но можно указать параметры накачивания и распространения. Помимо прочего, алгоритм работает как с ориентированными, так и с неориентированными графами.
